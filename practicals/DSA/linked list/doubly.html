<script>
    class Node {
        constructor(element) {
            this.element = element;
            this.next = null;
            this.prev = null;
        }
    }
    class LinkedList {
        constructor() {
            this.head = null;
            this.size = 0;
        }
        create_list(element) {
            var node = new Node(element);
            var current;
            if (this.head == null) {
                node.prev = null;
                this.head = node;
            } else {
                current = this.head;
                while (current.next) {
                    current = current.next;
                }
                current.next = node;
                node.prev = current;
            }
            this.size++;
        }
        insertToBegin(element) {
            var node = new Node(element);
            var current;
            current = this.head;
            node.next = this.head;
            this.head.prev = node;
            this.head = node;
            this.size++;
        }
        insertToLast(element) {
            var node = new Node(element);
            var curr;
            curr = this.head;
            var i = 0;
            while (curr.next != null)
                curr = curr.next;
            curr.next = node;
            node.prev = curr;
            this.size++;
        }
        insertAt(element, index) {
            if (index > 0 && index > this.size)
                return false;
            else {
                var node = new Node(element);
                var curr, curr1;
                curr = this.head;
                if (index == 0) {
                    node.next = this.head;
                    this.head.prev = node;
                    this.head = node;
                } else {
                    curr = this.head;
                    curr1 = curr.next;
                    var it = 1;
                    while (it < index) {
                        it++;
                        curr1 = curr1.next;
                        curr = curr.next;
                    }
                    curr1.prev = node;
                    node.next = curr1;
                    node.prev = curr;
                    curr.next = node;
                }
                this.size++;
            }
        }
        displayListForward() {
            var current = this.head;
            while (current) {
                console.log(current.element + " ");
                current = current.next;
            }
        }
        displayListBackward() {
            var current = this.head;
            while (current.next != null)
                current = current.next;
            while (current) {
                console.log(current.element + " ");
                current = current.prev;
            }
        }
        deleteFrom(index) {
            if (index < 0 && index > this.size)
                return -1;
            else {
                var curr, previous, it = 0;
                curr = this.head;
                previous = curr;
                if (index == 1) {
                    this.head = curr.next;
                    this.head.prev = null;
                } else {
                    while (it < index - 1) {
                        it++;
                        previous = curr;
                        curr = curr.next;
                    }
                    previous.next = curr.next;
                }
                this.size--;
                return curr.element;
            }
        }
        deleteElement(data) {
            if (this.head.element == data) {
                var value = this.head.element;
                this.head = this.head.next;
                this.head.prev
                    = null;
                return value;
            }
            var previous = this.head;
            var current
                = previous.next;
            while (current.next != null) {
                if (current.element == data) {
                    previous.next = current.next;
                    current.next.prev = previous;
                    this.size--;
                    return current.element;
                }
                previous = current; current = current.next;
            }
            if (current.element == data) {
                previous.next = null;
                this.size--;
                return current.element;
            }
            return -1;
        }
        search(data) {
            var current = this.head;
            var flag = 0; var position = 1;
            while (current) {
                if (current.element == data) {
                    flag = 1;
                    break;
                }
                position++;
                current = current.next;
            }
            if (flag == 1)
                console.log(data + "element is found at" + position + " position");
            else
                console.log(data + " is not found in the list")
        }
        count() {
            return this.size;
        }
    }
    var ll = new LinkedList();
    ll.create_list(10);
    ll.displayListForward();
    console.log("Insertion at Beginning :");
    ll.insertToBegin(65);
    ll.displayListForward();
    console.log("Insertion at last :");
    ll.insertToLast(50);
    ll.displayListForward();
    console.log("Insertion at Specified Position :");
    ll.insertAt(44, 2);
    ll.displayListForward();
    ans = ll.deleteElement(10);
    if (ans == -1)
        console.log("Element" + data + " is not found in the list");
    else {
        console.log("Deleted Element is =" + ans);
        ll.displayListForward();
    }
    console.log("Deletion from Position :");
    ans = ll.deleteFrom(1);
    if (ans == -1)
        console.log("position is not within the range ");
    else {
        console.log("Deleted Element is =" + ans);
        ll.displayListForward();
    }
    ll.search(10);
    console.log("Total number of nodes in the linked list = " + ll.count());
    ll.displayListForward();
    console.log("Reverse list :");
    ll.displayListBackward();

</script>